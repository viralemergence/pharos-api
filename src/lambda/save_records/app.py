import json
import os
from typing import Dict

import boto3
from auth import check_auth
from botocore.exceptions import ClientError
from format import format_response
from pydantic import BaseModel, Extra, Field, ValidationError
from register import Record, Register

S3CLIENT = boto3.client("s3")
DATASETS_S3_BUCKET = os.environ["DATASETS_S3_BUCKET"]


class SaveRecordsData(BaseModel):
    """Data model for the save records request"""

    project_id: str = Field(alias="projectID")
    dataset_id: str = Field(alias="datasetID")
    records: Dict[str, Record]

    class Config:
        extra = Extra.forbid


def lambda_handler(event, _):
    try:
        user = check_auth(event)
    except ValidationError as e:
        return format_response(400, "Not Authorized")

    if not user:
        return format_response(400, "Not Authorized")

    if not user.project_ids:
        return format_response(400, "Not Authorized")

    try:
        validated = SaveRecordsData.parse_raw(event["body"])
    except ValidationError as e:
        return format_response(400, e.json())

    if validated.project_id not in user.project_ids:
        return format_response(400, "Researcher does not have access to this project")

    previous_register_json = """{"register":{}}"""

    # check to make sure all records are in the same page
    page: int | None = None
    for record_id in validated.records:
        # record_id format is 'recXX|YYYYYY'
        # where XX is a page number of any
        # length and YYYYYY is a randomly
        # generated string generated by
        # nanoID (with an alphabet excluding
        # the '|' character).
        parts = record_id.split("|")

        # Legacy (pre-pagination) record_ids
        # do not include the '|' character.

        # simply skip legacy (pre-pagination)
        # record_ids and leave 'page' as None
        if len(parts) != 0:
            record_page = int(parts[0].replace("rec", ""))
            if page is None:
                page = record_page
            elif page != record_page:
                return format_response(
                    400, "All records in each request must be stored in the same page"
                )

    if page is None:
        key = f"{validated.dataset_id}/data.json"
    else:
        key = f"{validated.dataset_id}/data_{page}.json"

    # Check for previous records
    try:
        previous_register_json = (
            S3CLIENT.get_object(Bucket=DATASETS_S3_BUCKET, Key=key)["Body"]
            .read()
            .decode("utf-8")
        )

    except ClientError as e:
        if e.response.get("Error", {}).get("Code") == "NoSuchKey":
            pass
        else:
            return format_response(500, e)

    previous = json.loads(previous_register_json)
    response_register = Register.parse_obj({"register": validated.records})

    for record_id, record in validated.records.items():
        if previous["register"].get(record_id):
            previous_record = Record(**previous["register"][record_id])
            merge_result = Record.merge(previous_record, record)

            if merge_result is None:
                return format_response(400, "Record merge failed")

            response_register.register_data[record_id] = merge_result
            previous["register"][record_id] = json.loads(
                merge_result.json(by_alias=True, exclude_none=True)
            )

        else:
            previous["register"][record_id] = json.loads(
                validated.records[record_id].json(by_alias=True, exclude_none=True)
            )

    try:
        # Dump the modified register to JSON
        previous_register_json = json.dumps(previous)
        # Create a unique key by combining the datasetID and the register hash
        encoded_data = bytes(previous_register_json.encode("utf-8"))

        # Save new register object to S3 bucket
        S3CLIENT.put_object(Bucket=DATASETS_S3_BUCKET, Body=(encoded_data), Key=key)

        return format_response(
            200,
            response_register.json(by_alias=True, exclude_none=True),
            preformatted=True,
        )

    except Exception as e:  # pylint: disable=broad-except
        return format_response(403, e)
